#修改时间：2018/5/20
#修改了timeStamp结构，将原来占用24Byte改为占用3Byte，因为比如像年份这样的字段不用
#去掉了不必要的注释

#修改时间：2018/5/18
#发现在对应用层加同步锁出现BUG，死锁问题以及同步问题
#发现程序在运行时做了很多不必要的堆操作,将程序中的获取时间以及获取路径都使用栈操作(局部变量)
#解决了死锁问题和同步问题
#解决了产生数据时的BUG

#修改时间：2018/5/17
#在原来的基础上做出了很大改动，有以下几点:
#1)用抛出事件的方式替代原来的简单打印的方式
#2)封装了一下在sparc-gcc和gcc都能够使用的sleep_ms接口
#3)增加了同步机制模块,模块包含一个自己实现的哈希表部分和控制同步互斥的数据结构模块
#  自动哈希表模块能产生5种类型的hash key，目前使用了两种
#  控制同步互斥的数据结构有三个字段，分别是flag,mutex,cond,用来控制线程间同步
#  哈希表会将所述控制同步互斥数据结构散列到相应位置，使用拉链法解决冲突
#4)对应用层读写接口加了同步锁，其在没有读到数据的情况下会自动挂起，由交通灯模块唤醒
#5)对BC端的打包接口加了同步锁，使得数据打包完成后可以立刻唤醒数据转发线程进行处理
#6)修改了相关文件，删掉了不必要的注释。
#7)对两种模式都进行了测试，目前测试正常。

#修改时间：2018/5/16
#准备使用同步机制优化系统，完成最后几步工作

#修改时间：2018/5/15
#解决了使用VCAN接口丢失数据的BUG，原因是在中断程序中使用了锁机制
#解决了写入数据测试文件的冲突问题
#整理了一下工程里面的文件

#修改时间：2018/5/12

#vcan接口可以单词发送8字节以内的数据，但对外不具有封装性，device结构需要隐藏
，不具有发送一串字符串的能力。
#测试封装好的接口可以使用后，发现只能使用死等的方式确定是否有数据接受，使用
同步锁进一步修改接口。
#在RT端同样封装一层能够用的vcan接口，所述接口能够发送指定的字符串，然后BC与RT
端联调，确定能够正常收发数据。
#与TCPIP不同，vcan只能一次最多发送8字节数据，因此需要对原来的数据包收发加收发
控制，后加入控制帧收发的控制机制，经多次测试，基本确定可以使用。
#对必要地方添加了宏申明，使得两种通信模式下程序能正常编译。
#对原来TCPIP传输方式下的数据包进行修改，头部加入整个数据帧长度字段，对于vcan传
输模式，我使用了两种方式的帧，一种为大小帧，另外一种为数据帧。
#对有些需要加入sleep的地方进行的相应修改，因为sparc-elg-gcc没有直接的usleep，
两种通信模式下传输延迟不一样，后面可能会使用锁机制来提高系统效率。
