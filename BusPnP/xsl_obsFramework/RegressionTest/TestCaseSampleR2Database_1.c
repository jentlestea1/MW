  
//
// Copyright 2003 P&P Software GmbH - All Rights Reserved
//
// TestCaseSampleR2Database_1.c
//
// This file was automatically generated by an XSL program
//
ID_SAMPLER2DATABASE
#include "../GeneralInclude/CompilerSwitches.h"
#include "../GeneralInclude/ClassId.h"
#include "../GeneralInclude/Constants.h"
#include "../Data/DC_SampleR2Database.h"
#include "TestCaseSampleR2Database_1.h"
#include "../Utilities/TestCaseWithEvtCheck.h"

#include <math.h>
#include <float.h>


/////////////////////////////////////////////////////////////////////////////////
//
//                    non-pure virtual  method(s) definition
//
/////////////////////////////////////////////////////////////////////////////////



static void runTestCase(void *obj,TD_Integer value)
{
   // Data structures to simulate the default and operational tables
   // (The size of the database is read from the Parameter Database
   // Descriptor file).
   unsigned int dbLength = 50;
   unsigned char* defaultTable = new unsigned char[dbLength];
   unsigned char* operationalTable = new unsigned char[dbLength];

   // Initialize the default database. Each parameter is given a
   // value equal to its parameter ID. The parameter ID is read from
   // the Parameter Database Descriptor File. Note that this
   // strategy will sometimes result in an attempt to assign to a
   // parameter a value that is inconsistent with its type (e.g. a
   // a parameter of type 'char' might have a parameter ID greater than
   // 256).
   unsigned char* uc;
   
   uc = (defaultTable+0);
   *(float*)uc = (float)1;
   uc = (defaultTable+8);
   *(float*)uc = (float)2;
   uc = (defaultTable+16);
   *(float*)uc = (float)3;
   uc = (defaultTable+24);
   *(float*)uc = (float)4;

   // Get current number of events in event repository
   unsigned int nEvt;
   nEvt = getNumberOfEvents();

   // Initialize the operational database to all zeros
   for (unsigned int i=0; i<dbLength; i++)
       operationalTable[i]=0;

   // Instantiate parameter database
   DC_SampleR2Database* pDB = new DC_SampleR2Database();

   // Variable to hold the maximum parId
   TD_DatabaseId maxParId;
   maxParId = 4;

   // Variable to hold the lowest illegal parId
   TD_DatabaseId illegalParId;
   illegalParId = 5;

   // Verify correctness of class ID
   if (pDB->getClassId() != ID_SAMPLER2DATABASE)
   {      setTestResult(TEST_FAILURE, "Wrong class ID");
            return;
    }

   // Check that database is not yet configured
   if ( pDB->isObjectConfigured() != NOT_CONFIGURED )
   {      setTestResult(TEST_FAILURE, "Incorrect configuration status at creation");
            return;
    }

   // Configure database
   pDB->setDefaultTable((char*)defaultTable);
   pDB->setOperationalTable((char*)operationalTable);
   pDB->reset();

   // Check that database is configured
   if ( pDB->isObjectConfigured() != CONFIGURED )
   {      setTestResult(TEST_FAILURE, "Incorrect configuration status after configuration was completed");
            return;
   }

   // Check the pointer getter methods
   
   if ((unsigned char*)pDB->getParameterPointerFloat(1)!=operationalTable+0)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }
   if ((unsigned char*)pDB->getParameterPointerFloat(2)!=operationalTable+8)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }
   if ((unsigned char*)pDB->getParameterPointerFloat(3)!=operationalTable+16)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }
   if ((unsigned char*)pDB->getParameterPointerFloat(4)!=operationalTable+24)
   {      setTestResult(TEST_FAILURE, "Incorrect pointer value for parameter");
            return;
   }

   // Check that non-real paramaters have the correct value
   

   // Check that real parameters have the correct value
   
   if (fabs(pDB->getParameterFloat(1)-1) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }
   if (fabs(pDB->getParameterFloat(2)-2) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }
   if (fabs(pDB->getParameterFloat(3)-3) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }
   if (fabs(pDB->getParameterFloat(4)-4) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter");
            return;
   }

   // Update the value of all parameters by setting it equal to their (parId+1)
   
   pDB->setParameter(1,(float)(1+1)); 
   pDB->setParameter(2,(float)(2+1)); 
   pDB->setParameter(3,(float)(3+1)); 
   pDB->setParameter(4,(float)(4+1)); 

   // Check that non-real paramaters have the correct value
   

   // Check that real paramaters have the correct value
   
   if (fabs(pDB->getParameterFloat(1)-(1+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 1");
            return;
   } 
   if (fabs(pDB->getParameterFloat(2)-(2+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 2");
            return;
   } 
   if (fabs(pDB->getParameterFloat(3)-(3+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 3");
            return;
   } 
   if (fabs(pDB->getParameterFloat(4)-(4+1)) > DBL_EPSILON)
   {      setTestResult(TEST_FAILURE, "Incorrect value for parameter 4");
            return;
   } 
   // Check the setter and pointer methods generate event reports when they are accessed either
   // with an out-of-range parameter value or with an illegal parameter value
   if (isNonNominalCheckAllowed()) {
        char* dummy_1;

        pDB->setParameter(maxParId+1,(int)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(int)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerInt(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerInt(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(unsigned int)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(unsigned int)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerUnsignedInt(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerUnsignedInt(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(short)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(short)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerShort(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerShort(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(unsigned short)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(unsigned short)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerUnsignedShort(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerUnsignedShort(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(char)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(char)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerChar(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerChar(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(unsigned char)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(unsigned char)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerUnsignedChar(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerUnsignedChar(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(bool)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(bool)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerBool(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerBool(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(float)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(float)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerFloat(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerFloat(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
        pDB->setParameter(maxParId+1,(double)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        pDB->setParameter(illegalParId,(double)0);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
           return;
        nEvt++;  

        dummy_1 = (char*)pDB->getParameterPointerDouble(maxParId+1);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 

        dummy_1 = (char*)pDB->getParameterPointerDouble(illegalParId);
        if ( !verifyLatestEvent(nEvt+1,EVT_ILLEGAL_DB_ACCESS) )
            return;
        nEvt++; 
    }
    
	setTestResult(TEST_SUCCESS,"Test Successful");
	return;
}



///////////////////////////////////////////////////////////////////////////////
//
//                   object constructor and destructor
//
///////////////////////////////////////////////////////////////////////////////

// the following may be useful if you don't need it, just delete.
// TestCaseSampleR2Database_1 *this = TESTCASESAMPLER2DATABASE_1(obj)

/**
 * Set the identifier and the name of the test case to: 
 * ID_SAMPLER2DATABASE*10+1 and "TestCaseSampleR2Database_1".
 */
static void instance_init(Object *obj)
{
    (TestCase*)(obj)->testId=ID_SAMPLER2DATABASE*10+1;
    (TestCase*)(obj)->testName=TestCaseSampleR2Database_1;
    return;
}

TestCaseSampleR2Database_1* TestCaseSampleR2Database_1_new(void)
{
        return (TestCaseSampleR2Database_1*)object_new(TYPE_TESTCASESAMPLER2DATABASE_1);

}



///////////////////////////////////////////////////////////////////////////////
//
//                   binding and type registration
//
///////////////////////////////////////////////////////////////////////////////

static void class_init(ObjectClass *oc, void *data)
{
TestCaseSampleR2Database_1Class *t_p_class = TESTCASESAMPLER2DATABASE_1_CLASS(oc);

        t_p_class->runTestCase = runTestCase;

}

static const TypeInfo type_info = {
        .name = TYPE_TESTCASESAMPLER2DATABASE_1,
        .parent = TYPE_TESTCASEWITHWITHEVTCHECK,
        .instance_size = sizeof(TestCaseSampleR2Database_1),
        .abstract = false,
        .class_size = sizeof(TestCaseSampleR2Database_1Class),
        .instance_init = instance_init,
        .class_init = class_init,

};

void TestCaseSampleR2Database_1_register(void)
{
        type_register_static(&type_info);

}

