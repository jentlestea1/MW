<?xml version="1.0" encoding="UTF-8"?>

<!--================================================================-->
<!-- Copyright 2003 P&P Software GmbH                               -->
<!--================================================================-->

<!--===================================================================
Generator meta-component for a parameter database class for the OBS Framework.

This XSL program generates the body file of the parameter database
class.

This XSL program processes the XML-based application model.
===================================================================-->

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="1.1"
    xmlns:lxslt="http://xml.apache.org/xslt"
    xmlns:redirect="org.apache.xalan.lib.Redirect"
    extension-element-prefixes="redirect">

<xsl:strip-space elements="*"/>
<xsl:output omit-xml-declaration="yes" method="text"/>

<!--===================================================================
       Include general utility rules
===================================================================-->
 <xsl:include href="ClassNameFromPath.xsl"/>
 <xsl:include href="ClassIdFromClassName.xsl"/>
<xsl:include href="WriteCommentBody.xsl"/>
<xsl:include href="MakeFirstLetterCap.xsl"/>
<!--===================================================================
      Top-level rule 
===================================================================-->
<xsl:template match="/ObsApplication/ParameterDatabase/IndexedDatabase">
<!--===================================================================
      Define general-purpose variables
 ===================================================================-->  
  <xsl:variable name="ClassName">
        <xsl:call-template name="ClassNameFromPath">
              <xsl:with-param name="path" select="@type"/>
        </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="ClassId">
        <xsl:call-template name="ClassIdFromClassName">
              <xsl:with-param name="className" select="$ClassName"/>
        </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="CodeDir" select="'../'"/>
  <xsl:variable name="Level" select="RobustnessLevel/@value"/>

  <!-- compute and store the maximum parameter ID value           -->
  <xsl:variable name="maxParId">
    <xsl:call-template name="computeMaxParId">
       <xsl:with-param name="currentMax" select="0"/>
       <xsl:with-param name="currentPos" select="1"/>
    </xsl:call-template>
  </xsl:variable>
  
  <!-- start code generation                                       -->
  <xsl:variable name="TargetFile" select="concat('/home/wangshaobo/obs_xml_xsl/projects_c/',@type)"/>     
  Generating code for class <xsl:value-of select="$ClassName"/> in files <xsl:value-of select="$TargetFile"/>.c

  <!-- Check whether writing to an output file is possible -->
  <xsl:if test="not(element-available('xsl:document'))">
        FATAL ERROR: the xsl:document element is not supported. Header files cannot be written! This element
        is normally supported only in version 1.1 of XSL.
  </xsl:if>
  <xsl:variable name="LowerCase" select="'abcdefghijklmnopqrstuvwxyz'"/>
  <xsl:variable name= "UpperCase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
  <!-- ===================================================================================
         Create the output file  
          ===================================================================================-->
  <xsl:document href="{$TargetFile}.c" omit-xml-declaration="yes" method="text">  
//
// Copyright 2003 P&amp;P Software GmbH - All Rights Reserved
//
// <xsl:value-of select="$ClassName"/>.c
//
// This file was automatically generated by an XSL program
//

#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/CompilerSwitches.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/DebugSupport.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/BasicTypes.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/ClassId.h"
#include "<xsl:value-of select="$CodeDir"/>GeneralInclude/Constants.h"
<xsl:if test="$Level!=1">#include "<xsl:value-of select="$CodeDir"/>Base/CC_RootObject.h"</xsl:if>
#include "<xsl:value-of select="$ClassName"/>.h"

static unsigned int const CharCode = 1;
static unsigned int const UnsignedCharCode = 2;
static unsigned int const ShortCode = 3;
static unsigned int const UnsignedShortCode = 4;
static unsigned int const IntCode = 5;
static unsigned int const UnsignedIntCode = 6;
static unsigned int const BoolCode = 7;
static unsigned int const FloatCode = 8;
static unsigned int const DoubleCode = 9;

<!--
<xsl:value-of select="$ClassName"/>::<xsl:value-of select="$ClassName"/>() {
   setClassId(<xsl:value-of select="$ClassId"/>);
   pDefaultTable = pNULL;
   pOperationalTable = pNULL;
   resetWasCalled = false;

   tableLength = <xsl:value-of select="Size/@value"/>;

   maxParId = <xsl:value-of select="$maxParId"/>;
   pPar = new char*[maxParId+1];
   parType = new char[maxParId+1];
   for (TD_DatabaseId i=0; i&lt;maxParId; i++)  {
       pPar[i] = pNULL;
       parType[i] = -1;
   }

}

void <xsl:value-of select="$ClassName"/>::reset() {
   assert( pDefaultTable != pNULL ) ;
   assert( pOperationalTable != pNULL );
   assert( tableLength > 0 );
   for (TD_DatabaseId i=0; i&lt;tableLength; i++)
      pOperationalTable[i] = pDefaultTable[i];
   resetWasCalled = true;
<xsl:for-each select="Parameter">
  <xsl:sort select="Id/@value" data-type="number"/>
   pPar[<xsl:value-of select="Id/@value"/>] = pOperationalTable+<xsl:value-of 
                                                        select="Offset/@value"/>;<xsl:text/>
  <xsl:variable name="type" select="Type/@value"/>
  <xsl:choose>
    <xsl:when test="$type='unsigned int'">
   parType[<xsl:value-of select="Id/@value"/>] = UnsignedIntCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='int'">
   parType[<xsl:value-of select="Id/@value"/>] = IntCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='unsigned short'">
   parType[<xsl:value-of select="Id/@value"/>] = UnsignedShortCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='short'">
   parType[<xsl:value-of select="Id/@value"/>] = ShortCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='unsigned char'">
   parType[<xsl:value-of select="Id/@value"/>] = UnsignedCharCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='char'">
   parType[<xsl:value-of select="Id/@value"/>] = CharCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='bool'">
   parType[<xsl:value-of select="Id/@value"/>] = BoolCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='double'">
   parType[<xsl:value-of select="Id/@value"/>] = DoubleCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='float'">
   parType[<xsl:value-of select="Id/@value"/>] = FloatCode;<xsl:text/>
    </xsl:when>
  </xsl:choose>
</xsl:for-each>

}

void <xsl:value-of select="$ClassName"/>::setDefaultTable(char* pDefTable) {
   assert( pDefTable != pNULL );
   pDefaultTable = pDefTable;
}

void <xsl:value-of select="$ClassName"/>::setOperationalTable(char* pOperTable) {
   assert( pOperTable != pNULL );
   pOperationalTable = pOperTable;
}

bool <xsl:value-of select="$ClassName"/>::isObjectConfigured() {

   // Check configuration of super object
   if ( !CC_RootObject::isObjectConfigured() )
       return NOT_CONFIGURED;

   if ( (tableLength &lt;= 0) ||
        (pDefaultTable == pNULL) ||
        (pOperationalTable == pNULL) ||
        (!resetWasCalled) )
       return NOT_CONFIGURED;
   return CONFIGURED;
}
-->

///////////////////////////////////////////////////////////////////////////////
//
//                  non-virtual member method(s) definition
//
///////////////////////////////////////////////////////////////////////////////



void <xsl:value-of select="$ClassName"/>_setDefaultTable(<xsl:value-of select="$ClassName"/> *this, char* pDefTable){
   assert( pDefTable != pNULL );
   this->pDefaultTable = pDefTable;
}

void <xsl:value-of select="$ClassName"/>_setOperationalTable(<xsl:value-of select="$ClassName"/> *this, char* pOperTable){
   assert( pOperTable != pNULL );
   this->pOperationalTable = pOperTable;
}





///////////////////////////////////////////////////////////////////////////////
//
//                    non-pure virtual  method(s) definition
//
///////////////////////////////////////////////////////////////////////////////



static void reset(void *obj)
{
assert( <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pDefaultTable != pNULL ) ;
assert( <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pOperationalTable != pNULL );
   assert( <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->tableLength > 0 );
   for (TD_DatabaseId i=0; i&lt;<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->tableLength; i++)
      <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pOperationalTable[i] = <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pDefaultTable[i];
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->resetWasCalled = true;


<xsl:for-each select="Parameter">
  <xsl:sort select="Id/@value" data-type="number"/>
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pPar[<xsl:value-of select="Id/@value"/>] = <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pOperationalTable+<xsl:value-of 
                                                        select="Offset/@value"/>;<xsl:text/>
  <xsl:variable name="type" select="Type/@value"/>
  <xsl:choose>
    <xsl:when test="$type='unsigned int'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = UnsignedIntCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='int'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = IntCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='unsigned short'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = UnsignedShortCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='short'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = ShortCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='unsigned char'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = UnsignedCharCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='char'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = CharCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='bool'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = BoolCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='double'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = DoubleCode;<xsl:text/>
    </xsl:when>
    <xsl:when test="$type='float'">
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[<xsl:value-of select="Id/@value"/>] = FloatCode;<xsl:text/>
    </xsl:when>
  </xsl:choose>
</xsl:for-each>
}

<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'int'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>   
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'unsigned int'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'short'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'unsigned short'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'char'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'unsigned char'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'bool'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'float'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="setParameterMethod">
   <xsl:with-param name="type" select="'double'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>

<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'int'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'unsigned int'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'short'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'unsigned short'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'char'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'unsigned char'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'bool'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'float'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getParameterMethod">
   <xsl:with-param name="type" select="'double'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>

<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'int'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'unsigned int'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'short'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'unsigned short'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'char'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'unsigned char'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'bool'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'float'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>
<xsl:call-template name="getPointerMethod">
   <xsl:with-param name="type" select="'double'"/>
   <xsl:with-param name="level" select="$Level"/>
   <xsl:with-param name="ClassName" select="$ClassName"/>
</xsl:call-template>


///////////////////////////////////////////////////////////////////////////////
//
//                   object constructor and destructor
//
///////////////////////////////////////////////////////////////////////////////

// the following may be useful if you don't need it, just delete.
// <xsl:value-of select="$ClassName"/> *this = <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)
static void instance_init(Object *obj)
{
   <xsl:value-of select="translate(CC_RootObject,$LowerCase,$UpperCase)"/>(obj)->setClassId(<xsl:value-of select="$ClassId"/>);
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pDefaultTable = pNULL;
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pOperationalTable = pNULL;
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->resetWasCalled = false;

   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId = <xsl:value-of select="$maxParId"/>;
   <!--pPar = new char*[maxParId+1];-->
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pPar = (char*)malloc(maxParId+1);
   <!--parType = new char[maxParId+1];-->
   <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType = (char*)malloc(maxParId+1);
   for (TD_DatabaseId i=0; i&lt;<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId; i++)  {
       <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pPar[i] = pNULL;
       <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[i] = -1;
   }

}
<xsl:value-of select="$ClassName"/> *<xsl:value-of select="$ClassName"/>_new(void)
{
    return (<xsl:value-of select="$ClassName"/>*)object_new(TYPE_<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>);
}



///////////////////////////////////////////////////////////////////////////////
//
//                   binding and type registration
//
///////////////////////////////////////////////////////////////////////////////

static void class_init(ObjectClass *oc, void *data)
{
    DC_SampleR2DatabaseClass *dc_sr2dc = DC_SAMPLER2DATABASE_CLASS(oc);

    dc_sr2dc->reset = reset;
    dc_sr2dc->setParameterInt = setParameterInt;
    dc_sr2dc->setParameterUnsignedInt = setParameterUnsignedInt;
    dc_sr2dc->setParameterShort = setParameterShort;
    dc_sr2dc->setParameterUnsignedShort = setParameterUnsignedShort;
    dc_sr2dc->setParameterChar = setParameterChar;
    dc_sr2dc->setParameterUnsignedChar = setParameterUnsignedChar;
    dc_sr2dc->setParameterBool = setParameterBool;
    dc_sr2dc->setParameterFloat = setParameterFloat;
    dc_sr2dc->setParameterDouble = setParameterDouble;
    dc_sr2dc->getParameterInt = getParameterInt;
    dc_sr2dc->getParameterUnsignedInt = getParameterUnsignedInt;
    dc_sr2dc->getParameterShort = getParameterShort;
    dc_sr2dc->getParameterUnsignedShort = getParameterUnsignedShort;
    dc_sr2dc->getParameterChar = getParameterChar;
    dc_sr2dc->getParameterUnsignedChar = getParameterUnsignedChar;
    dc_sr2dc->getParameterBool = getParameterBool;
    dc_sr2dc->getParameterFloat = getParameterFloat;
    dc_sr2dc->getParameterDouble = getParameterDouble;
    dc_sr2dc->getParameterPointerInt = getParameterPointerInt;
    dc_sr2dc->getParameterPointerUnsignedInt = getParameterPointerUnsignedInt;
    dc_sr2dc->getParameterPointerShort = getParameterPointerShort;
    dc_sr2dc->getParameterPointerUnsignedShort = getParameterPointerUnsignedShort;
    dc_sr2dc->getParameterPointerChar = getParameterPointerChar;
    dc_sr2dc->getParameterPointerUnsignedChar = getParameterPointerUnsignedChar;
    dc_sr2dc->getParameterPointerBool = getParameterPointerBool;
    dc_sr2dc->getParameterPointerFloat = getParameterPointerFloat;
    dc_sr2dc->getParameterPointerDouble = getParameterPointerDouble;
    dc_sr2dc->isObjectConfigured = isObjectConfigured;
    
}

static const TypeInfo type_info = {
    .name = TYPE_<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>,   
    .parent = TYPE_PARAMETERDATABASE,
    .instance_size = sizeof(<xsl:value-of select="$ClassName"/>),
    .abstract = false,
    .class_size = sizeof(<xsl:value-of select="$ClassName"/>Class),
    .instance_init = instance_init,
    .class_init = class_init,
};

void <xsl:value-of select="$ClassName"/>_register(void)
{
    type_register_static(&amp;type_info);
}

</xsl:document>
</xsl:template>

<xsl:variable name="LowerCase" select="'abcdefghijklmnopqrstuvwxyz'"/>
<xsl:variable name= "UpperCase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
<!--================================================================-->
<!-- Utility to compute the maximum value of the parId field on     -->
<!-- all the Parameter elements.                                    -->
<!-- When it is called the first time, the parameter 'currentMax'   -->
<!-- should be set to zero and the parameter 'currentPos' should be -->
<!-- set to 1.                                                      -->
<!--================================================================-->

<xsl:template name="computeMaxParId">
  <xsl:param name="currentMax"/>
  <xsl:param name="currentPos"/>
  <xsl:choose>
    <xsl:when test="$currentPos=count(//Parameter)">
      <xsl:value-of select="$currentMax"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="valOfNextParId" select="//Parameter[$currentPos+1]/Id/@value"/>
      <xsl:choose>
        <xsl:when test="$currentMax &lt; $valOfNextParId">
          <xsl:call-template name="computeMaxParId">
            <xsl:with-param name="currentMax" select="$valOfNextParId"/>
            <xsl:with-param name="currentPos" select="$currentPos+1"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="computeMaxParId">
            <xsl:with-param name="currentMax" select="$currentMax"/>
            <xsl:with-param name="currentPos" select="$currentPos+1"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<!--================================================================-->
<!-- Utility to write out the definiton of a parameter setter       -->
<!-- method.                                                        -->
<!-- The first template parameter is the name of the type of the    -->
<!-- database parameter. The second template parameter is the       -->
<!-- robustness level of the database. The third template parameter -->
<!-- is the name of the class being generated.                      -->
<!--================================================================-->

<xsl:template name="setParameterMethod">
  <xsl:param name="type"/>
  <xsl:param name="level"/>
  <xsl:param name="ClassName"/>
  <xsl:variable name="normalizedType">
      <xsl:call-template name="MakeFirstLetterCap">
        <xsl:with-param name="before" select="''"/>
        <xsl:with-param name="after" select="$type"/>
      </xsl:call-template>
   </xsl:variable>
static void setParameter<xsl:value-of select="$normalizedType"/>(void obj*, TD_DatabaseId parId, <xsl:value-of select="$type"/> newValue) {
   assert( <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pOperationalTable != pNULL );
   assert( (parId &lt;= <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId) &amp;&amp; (<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[parId]==<xsl:value-of select="$normalizedType"/>Code) );
   <xsl:if test="$level!='1'">
   if (parId > <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId) {
       DC_EventRepository* dc_e_r=CC_RootObject_getEventRepository();
      <xsl:value-of select="translate('DC_EventRepository',$LowerCase,$UpperCase)"/>_GET_CLASS(dc_e_r)->create(obj,EVT_ILLEGAL_DB_ACCESS);
       return;
   }
   if (<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[parId]!=<xsl:value-of select="$normalizedType"/>Code) {
       DC_EventRepository* dc_e_r=CC_RootObject_getEventRepository();
      <xsl:value-of select="translate('DC_EventRepository',$LowerCase,$UpperCase)"/>_GET_CLASS(dc_e_r)->create(obj,EVT_ILLEGAL_DB_ACCESS);
       return;
   }
   </xsl:if>
   *( (<xsl:value-of select="$type"/>*)(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pPar[parId]) ) = newValue;
}
</xsl:template>

<!--================================================================-->
<!-- Utility to write out the definiton of a parameter getter       -->
<!-- method.                                                        -->
<!-- The first template parameter is the name of the type of the    -->
<!-- database parameter. The second template parameter is the       -->
<!-- robustness level of the database. The third template parameter -->
<!-- is the name of the class being generated.                      -->
<!--================================================================-->

<xsl:template name="getParameterMethod">
  <xsl:param name="type"/>
  <xsl:param name="level"/>
  <xsl:param name="ClassName"/>
  <xsl:variable name="normalizedType">
      <xsl:call-template name="MakeFirstLetterCap">
        <xsl:with-param name="before" select="''"/>
        <xsl:with-param name="after" select="$type"/>
      </xsl:call-template>
   </xsl:variable>
static <xsl:value-of select="$type"/>* getParameter<xsl:value-of select="$normalizedType"/>(void *obj, TD_DatabaseId parId) {
   assert( <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pOperationalTable != pNULL );
   assert( (parId &lt;= <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId) &amp;&amp; (<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[parId]==<xsl:value-of select="$normalizedType"/>Code) );
   <xsl:if test="$level='3'">
   if (parId > <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId) {
       DC_EventRepository* dc_e_r=CC_RootObject_getEventRepository();
      <xsl:value-of select="translate('DC_EventRepository',$LowerCase,$UpperCase)"/>_GET_CLASS(dc_e_r)->create(obj,EVT_ILLEGAL_DB_ACCESS);
       return (<xsl:value-of select="$type"/>)0;
   }
   if (<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[parId]!=<xsl:value-of select="$normalizedType"/>Code) {
       DC_EventRepository* dc_e_r=CC_RootObject_getEventRepository();
      <xsl:value-of select="translate('DC_EventRepository',$LowerCase,$UpperCase)"/>_GET_CLASS(dc_e_r)->create(obj,EVT_ILLEGAL_DB_ACCESS);
       return (<xsl:value-of select="$type"/>)0;
   }
   </xsl:if>
   return *(<xsl:value-of select="$type"/>*)(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pPar[parId]);
}
</xsl:template>

<!--================================================================-->
<!-- Utility to write out the definiton of a parameter pointer      -->
<!-- getter method.                                                 -->
<!-- The first template parameter is the name of the type of the    -->
<!-- database parameter. The second template parameter is the       -->
<!-- robustness level of the database. The third template parameter -->
<!-- is the name of the class being generated.                      -->
<!--================================================================-->

<xsl:template name="getPointerMethod">
  <xsl:param name="type"/>
  <xsl:param name="level"/>
  <xsl:param name="ClassName"/>
  <xsl:variable name="normalizedType">
      <xsl:call-template name="MakeFirstLetterCap">
        <xsl:with-param name="before" select="''"/>
        <xsl:with-param name="after" select="$type"/>
      </xsl:call-template>
   </xsl:variable>
static <xsl:value-of select="$type"/>* getParameterPointer<xsl:value-of select="$normalizedType"/>(void *obj, TD_DatabaseId parId) {
   assert( <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pOperationalTable != pNULL );
   assert( (parId &lt;= <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId) &amp;&amp; (<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[parId]==<xsl:value-of select="$normalizedType"/>Code) );
   <xsl:if test="$level!='1'">
   if (parId > <xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->maxParId) {
       DC_EventRepository* dc_e_r=CC_RootObject_getEventRepository();
      <xsl:value-of select="translate('DC_EventRepository',$LowerCase,$UpperCase)"/>_GET_CLASS(dc_e_r)->create(obj,EVT_ILLEGAL_DB_ACCESS);
       return pNULL;
   }
   if (<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->parType[parId]!=<xsl:value-of select="$normalizedType"/>Code) {
       DC_EventRepository* dc_e_r=CC_RootObject_getEventRepository();
      <xsl:value-of select="translate('DC_EventRepository',$LowerCase,$UpperCase)"/>_GET_CLASS(dc_e_r)->create(obj,EVT_ILLEGAL_DB_ACCESS);
       return pNULL;
   }
   </xsl:if>
   return (<xsl:value-of select="$type"/>*)(<xsl:value-of select="translate($ClassName,$LowerCase,$UpperCase)"/>(obj)->pPar[parId]);
}
</xsl:template>



</xsl:stylesheet>
