
// Copyright 2004 P&P Software GmbH - All Rights Reserved
//
// CC_ComponentFactory.h
//
// This file was automatically generated by an XSL program

#ifndef CC_ComponentFactory_H
#define CC_ComponentFactory_H

#include "../GeneralInclude/ForwardDeclarations.h"
#include "../GeneralInclude/BasicTypes.h"
#include "CC_ComponentFactory_inc.h"
#include "../Base/CC_RootObject.h"   
#include <assert.h>
#include "../Qom/object.h"
/**
 * Application component factory.
 * This class creates and configures all the components required by the target application and makes
 * them available through getter methods. 
 * The components are created in the constructor and are then stored in an array.
 * A configuration method is provided that will configure all the created components.
 * The components can be accessed by clients exclusively through their pointers.
 * The pointers are returned by getter methods. There is one getter method for each
 * type of components managed by the component factory. The name of the getter
 * methods is of the form: <code>getXXX</code> where "XXX" is the type name
 * stripped of the initial prefix "DC_" or "CC_". The argument of the getter name is an
 * integer that represents the symbolic identifier of the component (it is an integer that, 
 * from the point of view of external components, acts 
 * as the component name). The symbolic identifiers of the components are stored in
 * the include file <code>CC_ComponentFactory_inc.h</code>. 
 * The getter methods return typed instances of the components. An assertion is used 
 * to verify that the getter method is consistent with the actual type of the component that
 * is being retrieved (i.e. to verify that a component of type "XXX" is retrieved with a call
 * to method <code>getXXX</code>). There are no other run-time checks
 * on the consistency of usage of the getter methods. This approach is justified because
 * the component factory should normally be used only during the application instantiation
 * phase and the type and order of the calls to the getter methods should be fixed. This
 * allows their correctness to be verified once and for all with assertions enabled.
 * <p>
 * This is a singleton class. Its only instance is accessed through its method 
 * <code>getInstance</code>.
 * <p>
 * This class is automatically generated by an XSL program that processes the XML-based
 * model of the target application.
 * <p>
 * This class manages a total of 101 components.
 * <p>
 * For reasons of efficiency, all getter methods are declared to be inline. 
 * <p>
 * Implementation note: this class maintains the component references in two distinct location.
 * For each component, a dedicated variable is delcared that holds the pointer to the component.
 * Additionally, an array <code>list</code> of pointers to the top-level type <code>CC_RootObject</code>
 * is declared that holds all the pointers to the components. The getter methods retrieve the components
 * from this array. The configuration methods instead use directly the component variables. 
 * Finally, an array of integers is provided that holds the values of the type identifiers for each
 * created component. 
 * @see CC_ComponentFactory_inc.h
 * @author Automatically Generated Class
 * @version 1.0
 */
 
 #define TYPE_CC_ComponentFactory "cc_componentfactory"
 
void CC_ComponentFactory_register(void);


/////////////////////////////////////////////////////////////////////////////////
//
//                              class and struct
//
/////////////////////////////////////////////////////////////////////////////////
struct CC_ComponentFactory {
    Object parent;
    DC_SampleFullDataPool* fullDataPool;
    DC_StuckDataProfile* sdMonProf_1;
    DC_OutOfRangeProfile* orMonProf_1;
    DC_SampleMonitoringProfile* sMonProf_1;
    DC_NullRecoveryAction* nRecAct_1;
    DC_OutOfRangeProfile* orMonProf_2;
    DC_SampleRecoveryAction* sRecAct_2;
    DC_NullRecoveryAction* nRecAct_2;
    DC_StuckDataProfile* sdMonProf_4;
    DC_OutOfRangeProfile* orMonProf_4;
    DC_NullRecoveryAction* nRecAct_4;
    DC_OutOfRangeProfile* orMonProf_5;
    DC_NullRecoveryAction* nRecAct_5;
    DC_StuckDataProfile* sdMonProf_7;
    DC_OutOfRangeProfile* orMonProf_7;
    DC_NullRecoveryAction* nRecAct_7;
    DC_OutOfRangeProfile* orMonProf_8;
    DC_NullRecoveryAction* nRecAct_8;
    DC_StuckDataProfile* sdMonProf_10;
    DC_OutOfRangeProfile* orMonProf_10;
    DC_NullRecoveryAction* nRecAct_10;
    DC_OutOfRangeProfile* orMonProf_11;
    DC_NullRecoveryAction* nRecAct_11;
    DC_SampleR2Database* parDB;
    CC_FSM* Nominal_FSM;
    DC_NestedFsmActivatorWithEndState* SBY_FsmState;
    DC_NestedFsmActivatorWithExitCheck* SAM_FsmState;
    DC_SCM_FsmState* SCM_FsmState;
    DC_OCM_FsmState* OCM_FsmState;
    DC_FromFsmEvent* SAM_to_OCM;
    DC_FromFsmEvent* OCM_to_SAM;
    DC_FromFsmEvent* SCM_to_SAM;
    DC_FromFsmEvent* SAM_to_SCM;
    DC_FromFsmEvent* SCM_to_OCM;
    DC_FromFsmEvent* OCM_to_SCM;
    CC_FSM* SBY_FSM;
    DC_SBY_PreSepFsmState* SBY_PreSeparation;
    DC_SBY_PostSepFsmState* SBY_PostSeparation;
    DC_DummyFsmState* END;
    CC_FSM* SAM_FSM;
    DC_UnstableFsmState* SAM_SunAcquisition;
    DC_DummyFsmState* SAM_SunPointing;
    CC_FSM* OCM_FSM;
    DC_UnstableFsmState* OCM_Slewing;
    DC_DummyFsmState* OCM_Pointing;
    DC_DummyFsmState* OCM_Thrusting;
    CC_FSM* SCM_FSM;
    DC_DummyFsmState* SCM_Slewing;
    DC_DummyFsmState* SCM_Pointing;
    DC_DummyFsmState* SCM_Scanning;
    CC_FSM* SM_FSM;
    DC_SM_PreSepFsmState* SM_PreSeparation;
    DC_UnstableFsmState* SM_PostSeparation;
    DC_UnstableFsmState* SM_SunAcquisition;
    DC_DummyFsmState* SM_SunPointing;
    DC_FromFsmEvent* SM_PreToPost;
    CC_FSM* FDIR_FSM;
    DC_AfsFsmState* AFS;
    DC_DummyFsmState* AFO;
    DC_FromFsmEvent* AFS_to_AFO;
    DC_FromFsmEvent* AFO_to_AFS;
    DC_ControlAction* contAction_1;
    DC_SampleControlBlock_1* contBlock_1;
    DC_ControlAction* contAction_2;
    DC_SampleControlBlock_2* contBlock_2;
    DC_ControlAction* contAction_3;
    DC_SampleControlBlock_3* contBlock_3;
    DC_ControlAction* contAction_4;
    DC_SampleControlBlock_4* contBlock_4;
    DC_DummyObsClock* obsClk;
    DC_PUSEventRepository* evtRep;
    DC_DummyTracer* tracer;
    CC_ManoeuvreManager* manMan;
    DC_DummyManoeuvre* man_1;
    DC_DummyConfigurableManoeuvre* man_2;
    DC_TestPUSConfigurableManoeuvre* man_3;
    CC_TelecommandManager* tcMan;
    DC_BasicPUSTcLoader* tcLoader;
    DC_DummyTelecommand* tc_1;
    DC_DummyTelecommand* tc_2;
    DC_DummyPUSTelecommand* tc_3;
    DC_PUSDefineDataReporting* tc_4;
    DC_PUSControlDataReporting* tc_5;
    DC_TestPUSTelecommand* tc_6;
    DC_TestPUSTelecommand* tc_7;
    DC_TestPUSTelecommand* tc_8;
    DC_PUSDumpMemoryAbsolute* tc_9;
    DC_PUSDumpMemoryOffset* tc_10;
    DC_PUSMemoryLoadAbsolute* tc_11;
    DC_PUSMemoryLoadAbsolute* tc_12;
    DC_PUSMemoryLoadOffset* tc_13;
    CC_TelemetryManager* tmMan;
    DC_BasicPUSTmStream* tmStream;
    DC_DummyPUSTelemetryPacket* tm_1;
    DC_DummyPUSTelemetryPacket* tm_2;
    DC_PUSTcVerificationPacket* tm_3;
    DC_PUSDataReportingPacket* tm_4;
    DC_PUSDataReportingPacket* tm_5;
    DC_PUSMemoryDumpAbsolute* tm_6;
    DC_PUSMemoryDumpOffset* tm_7;
    DC_PUSTelemetryModeManager* tmModeMan;
    
    CC_RootObject* list[101];
    int type[101+1];
};


struct CC_ComponentFactoryClass {
    ObjectClass parent_class;
    
};


#define CC_COMPONENTFACTORY_GET_CLASS(obj) \
         OBJECT_GET_CLASS(CC_ComponentFactoryClass, obj, TYPE_CC_COMPONENTFACTORY)


#define CC_COMPONENTFACTORY_CLASS(klass) \
         OBJECT_CLASS_CHECK(CC_ComponentFactoryClass, klass, TYPE_CC_COMPONENTFACTORY)


#define CC_COMPONENTFACTORY(obj) \
         OBJECT_CHECK(CC_ComponentFactory, obj, TYPE_CC_COMPONENTFACTORY)


CC_ComponentFactory* CC_ComponentFactory_new(void);
    
///////////////////////////////////////////////////////////////////////////////
//
//                            class method(s) declaration
//
///////////////////////////////////////////////////////////////////////////////


/**
 * Get the single instance of this singleton class. If the instance does not
 * yet exist, it is created.
 */
static CC_ComponentFactory* CC_ComponentFactorygetInstance(void);

///////////////////////////////////////////////////////////////////////////////
//
//                 non-virtual member method(s) declaration
//
///////////////////////////////////////////////////////////////////////////////

   /**
     * Configure the static part of the base class <code>CC_RootObject</code>. This method is called by method 
     * <code>configureApplication</code>
     */
    
     
     void CC_ComponentFactory_configureRootObject(CC_ComponentFactory *this);
   
    
    /**
     * Configure the component implementing the OBS Clock. This method is called by method 
     * <code>configureApplication</code>
     */
     void CC_ComponentFactory_configureObsClock(CC_ComponentFactory *this);
    
    /**
     * Configure the component implementing the event repository. This method is called by method 
     * <code>configureApplication</code>
     */
     void  CC_ComponentFactory_configureEventRepository (CC_ComponentFactory *this);
    
    /**
     * Configure the components implementing the applications FSMs. This method configures the
     * FSM, their FsmStates and their FsmEvents. This method is called by method 
     * <code>configureApplication</code>
     */
     void CC_ComponentFactory_configureFSM(CC_ComponentFactory *this);
    
    /**
     * Configure the components implementing the control actions and control blocks. This method is called by method 
     * <code>configureApplication</code>
     */
     void CC_ComponentFactory_configureControllers(CC_ComponentFactory *this);
    
    /**
     * Configure the components implementing the application data pool. This method is called by method 
     * <code>configureApplication</code>
     */
     void CC_ComponentFactory_configureDataPool(CC_ComponentFactory *this);
    
    /**
     * Configure the components implementing the parameter database. This method is called by method 
     * <code>configureApplication</code>
     */
     void CC_ComponentFactory_configureParameterDatabase(CC_ComponentFactory *this);
    

    /**
     * Configure the functionality managers. This method is called by method 
     * <code>configureApplication</code>
     */
     void CC_ComponentFactory_configureFunctionalityManagers(CC_ComponentFactory *this);


    /**
     * Configure the application. All the components created in the constructor are configured
     * and linked together. The configuration code implements the configuration actions specified
     * in the application model. The application configuration process is broken up into a sequence
     * of steps. To each step a protected method in this class is associated. This method only
     * calls the step methods in sequence. The names of the step methods are formed as
     * follows: <code>configureXXX</code> where "XXX" is the name of a feature in
     * the application whose configuration is covered by the method.
     */
    void CC_ComponentFactory_configureApplication(CC_ComponentFactory *this);


   /**
    * Getter method for components of type <code>DC_ControlAction</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_ControlAction</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_ControlAction* CC_ComponentFactory_getControlAction(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_ControlAction);
       return (DC_ControlAction*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_1</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_1</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleControlBlock_1* CC_ComponentFactory_getSampleControlBlock_1(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_1);
       return (DC_SampleControlBlock_1*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_2</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_2</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleControlBlock_2* CC_ComponentFactory_getSampleControlBlock_2(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_2);
       return (DC_SampleControlBlock_2*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_3</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_3</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleControlBlock_3* CC_ComponentFactory_getSampleControlBlock_3(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_3);
       return (DC_SampleControlBlock_3*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleControlBlock_4</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleControlBlock_4</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleControlBlock_4* CC_ComponentFactory_getSampleControlBlock_4(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleControlBlock_4);
       return (DC_SampleControlBlock_4*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleFullDataPool</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleFullDataPool</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleFullDataPool* CC_ComponentFactory_getSampleFullDataPool(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleFullDataPool);
       return (DC_SampleFullDataPool*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleR2Database</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleR2Database</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleR2Database* CC_ComponentFactory_getSampleR2Database(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleR2Database);
       return (DC_SampleR2Database*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSEventRepository</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSEventRepository</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSEventRepository* CC_ComponentFactory_getPUSEventRepository(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSEventRepository);
       return (DC_PUSEventRepository*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_NullRecoveryAction</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_NullRecoveryAction</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_NullRecoveryAction* CC_ComponentFactory_getNullRecoveryAction(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_NullRecoveryAction);
       return (DC_NullRecoveryAction*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_OutOfRangeProfile</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_OutOfRangeProfile</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_OutOfRangeProfile* CC_ComponentFactory_getOutOfRangeProfile(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_OutOfRangeProfile);
       return (DC_OutOfRangeProfile*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleMonitoringProfile</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleMonitoringProfile</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleMonitoringProfile* CC_ComponentFactory_getSampleMonitoringProfile(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleMonitoringProfile);
       return (DC_SampleMonitoringProfile*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SampleRecoveryAction</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SampleRecoveryAction</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SampleRecoveryAction* CC_ComponentFactory_getSampleRecoveryAction(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SampleRecoveryAction);
       return (DC_SampleRecoveryAction*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_StuckDataProfile</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_StuckDataProfile</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_StuckDataProfile* CC_ComponentFactory_getStuckDataProfile(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_StuckDataProfile);
       return (DC_StuckDataProfile*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_FSM</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_FSM</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline CC_FSM* CC_ComponentFactory_getFSM(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_FSM);
       return (CC_FSM*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_AfsFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_AfsFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_AfsFsmState* CC_ComponentFactory_getAfsFsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_AfsFsmState);
       return (DC_AfsFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyFsmState* CC_ComponentFactory_getDummyFsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyFsmState);
       return (DC_DummyFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_FromFsmEvent</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_FromFsmEvent</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_FromFsmEvent* CC_ComponentFactory_getFromFsmEvent(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_FromFsmEvent);
       return (DC_FromFsmEvent*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_NestedFsmActivatorWithEndState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_NestedFsmActivatorWithEndState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_NestedFsmActivatorWithEndState* CC_ComponentFactory_getNestedFsmActivatorWithEndState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_NestedFsmActivatorWithEndState);
       return (DC_NestedFsmActivatorWithEndState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_NestedFsmActivatorWithExitCheck</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_NestedFsmActivatorWithExitCheck</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_NestedFsmActivatorWithExitCheck* CC_ComponentFactory_getNestedFsmActivatorWithExitCheck(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_NestedFsmActivatorWithExitCheck);
       return (DC_NestedFsmActivatorWithExitCheck*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_OCM_FsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_OCM_FsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_OCM_FsmState* CC_ComponentFactory_getOCM_FsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_OCM_FsmState);
       return (DC_OCM_FsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SBY_PostSepFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SBY_PostSepFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SBY_PostSepFsmState* CC_ComponentFactory_getSBY_PostSepFsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SBY_PostSepFsmState);
       return (DC_SBY_PostSepFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SBY_PreSepFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SBY_PreSepFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SBY_PreSepFsmState* CC_ComponentFactory_getSBY_PreSepFsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SBY_PreSepFsmState);
       return (DC_SBY_PreSepFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SCM_FsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SCM_FsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SCM_FsmState* CC_ComponentFactory_getSCM_FsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SCM_FsmState);
       return (DC_SCM_FsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_SM_PreSepFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_SM_PreSepFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_SM_PreSepFsmState* CC_ComponentFactory_getSM_PreSepFsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_SM_PreSepFsmState);
       return (DC_SM_PreSepFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_UnstableFsmState</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_UnstableFsmState</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_UnstableFsmState* CC_ComponentFactory_getUnstableFsmState(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_UnstableFsmState);
       return (DC_UnstableFsmState*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_ManoeuvreManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_ManoeuvreManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline CC_ManoeuvreManager* CC_ComponentFactory_getManoeuvreManager(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_ManoeuvreManager);
       return (CC_ManoeuvreManager*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyConfigurableManoeuvre</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyConfigurableManoeuvre</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyConfigurableManoeuvre* CC_ComponentFactory_getDummyConfigurableManoeuvre(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyConfigurableManoeuvre);
       return (DC_DummyConfigurableManoeuvre*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyManoeuvre</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyManoeuvre</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyManoeuvre* CC_ComponentFactory_getDummyManoeuvre(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyManoeuvre);
       return (DC_DummyManoeuvre*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_TestPUSConfigurableManoeuvre</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_TestPUSConfigurableManoeuvre</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_TestPUSConfigurableManoeuvre* CC_ComponentFactory_getTestPUSConfigurableManoeuvre(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TestPUSConfigurableManoeuvre);
       return (DC_TestPUSConfigurableManoeuvre*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyObsClock</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyObsClock</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyObsClock* CC_ComponentFactory_getDummyObsClock(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyObsClock);
       return (DC_DummyObsClock*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyTracer</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyTracer</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyTracer* CC_ComponentFactory_getDummyTracer(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyTracer);
       return (DC_DummyTracer*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_TelecommandManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_TelecommandManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline CC_TelecommandManager* CC_ComponentFactory_getTelecommandManager(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TelecommandManager);
       return (CC_TelecommandManager*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_BasicPUSTcLoader</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_BasicPUSTcLoader</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_BasicPUSTcLoader* CC_ComponentFactory_getBasicPUSTcLoader(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_BasicPUSTcLoader);
       return (DC_BasicPUSTcLoader*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyPUSTelecommand</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyPUSTelecommand</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyPUSTelecommand* CC_ComponentFactory_getDummyPUSTelecommand(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyPUSTelecommand);
       return (DC_DummyPUSTelecommand*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyTelecommand</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyTelecommand</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyTelecommand* CC_ComponentFactory_getDummyTelecommand(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyTelecommand);
       return (DC_DummyTelecommand*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSControlDataReporting</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSControlDataReporting</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSControlDataReporting* CC_ComponentFactory_getPUSControlDataReporting(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSControlDataReporting);
       return (DC_PUSControlDataReporting*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDefineDataReporting</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDefineDataReporting</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSDefineDataReporting* CC_ComponentFactory_getPUSDefineDataReporting(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDefineDataReporting);
       return (DC_PUSDefineDataReporting*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDumpMemoryAbsolute</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDumpMemoryAbsolute</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSDumpMemoryAbsolute* CC_ComponentFactory_getPUSDumpMemoryAbsolute(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDumpMemoryAbsolute);
       return (DC_PUSDumpMemoryAbsolute*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDumpMemoryOffset</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDumpMemoryOffset</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSDumpMemoryOffset* CC_ComponentFactory_getPUSDumpMemoryOffset(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDumpMemoryOffset);
       return (DC_PUSDumpMemoryOffset*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryLoadAbsolute</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryLoadAbsolute</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSMemoryLoadAbsolute* CC_ComponentFactory_getPUSMemoryLoadAbsolute(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryLoadAbsolute);
       return (DC_PUSMemoryLoadAbsolute*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryLoadOffset</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryLoadOffset</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSMemoryLoadOffset* CC_ComponentFactory_getPUSMemoryLoadOffset(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryLoadOffset);
       return (DC_PUSMemoryLoadOffset*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_TestPUSTelecommand</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_TestPUSTelecommand</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_TestPUSTelecommand* CC_ComponentFactory_getTestPUSTelecommand(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TestPUSTelecommand);
       return (DC_TestPUSTelecommand*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>CC_TelemetryManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>CC_TelemetryManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline CC_TelemetryManager* CC_ComponentFactory_getTelemetryManager(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_TelemetryManager);
       return (CC_TelemetryManager*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_BasicPUSTmStream</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_BasicPUSTmStream</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_BasicPUSTmStream* CC_ComponentFactory_getBasicPUSTmStream(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_BasicPUSTmStream);
       return (DC_BasicPUSTmStream*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_DummyPUSTelemetryPacket</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_DummyPUSTelemetryPacket</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_DummyPUSTelemetryPacket* CC_ComponentFactory_getDummyPUSTelemetryPacket(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_DummyPUSTelemetryPacket);
       return (DC_DummyPUSTelemetryPacket*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSDataReportingPacket</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSDataReportingPacket</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSDataReportingPacket* CC_ComponentFactory_getPUSDataReportingPacket(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSDataReportingPacket);
       return (DC_PUSDataReportingPacket*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryDumpAbsolute</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryDumpAbsolute</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSMemoryDumpAbsolute* CC_ComponentFactory_getPUSMemoryDumpAbsolute(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryDumpAbsolute);
       return (DC_PUSMemoryDumpAbsolute*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSMemoryDumpOffset</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSMemoryDumpOffset</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSMemoryDumpOffset* CC_ComponentFactory_getPUSMemoryDumpOffset(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSMemoryDumpOffset);
       return (DC_PUSMemoryDumpOffset*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSTcVerificationPacket</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSTcVerificationPacket</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSTcVerificationPacket* CC_ComponentFactory_getPUSTcVerificationPacket(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSTcVerificationPacket);
       return (DC_PUSTcVerificationPacket*)list[compName];
   }
      
   /**
    * Getter method for components of type <code>DC_PUSTelemetryModeManager</code>.
    * An assertion exception is raised if the component that is sought with this method is not of type
    * <code>DC_PUSTelemetryModeManager</code>. An assertion exception is likewise raised 
    * if the value of the integer representing the component name is out of range (namely if it is negative
    * or greater than N where N is the total number of components managed by the component factory).
    * @param compName the name of the component as given by its numerical identifier
    * @return the pointer to the component
    */
    inline DC_PUSTelemetryModeManager* CC_ComponentFactory_getPUSTelemetryModeManager(CC_ComponentFactory *this, int compName) {
       assert( (compName>=1) && (compName<=101) );
       assert( type[compName]==TN_PUSTelemetryModeManager);
       return (DC_PUSTelemetryModeManager*)list[compName];
   }
      

#endif
